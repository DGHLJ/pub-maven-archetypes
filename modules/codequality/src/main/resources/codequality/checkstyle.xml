<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE module PUBLIC "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
		"http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
<module name="Checker">
	<!--
		FileSetCheck TreeWalker checks individual Java source
		files and defines properties that are applicable to
		checking such files.
	-->
	<module name="TreeWalker">
		<!-- -->
		<!-- Section: Annotations -->
		<!-- -->

		<!--
			This check controls the style with the usage of annotations.
		-->
		<module name="AnnotationUseStyle">
			<property name="ElementStyle" vaule="compact_no_array" />
			<!-- <property name="ElementStyle" vaule="expanded" /> -->

			<property name="TrailingArrayComma" vaule="never" />
			<!-- <property name="TrailingArrayComma" vaule="always" /> -->

			<property name="ClosingParens" vaule="always" />
			<!-- <property name="ClosingParens" vaule="never" /> -->
		</module>

		<!--
			Verifies that both the java.lang.Deprecated annotation
			is present and the @deprecated Javadoc tag is present
			when either is present.
		-->
		<module name="MissingDeprecated" />

		<!--
			Verifies that the java.lang.Override annotation is
			present when the {@inheritDoc} javadoc tag is present.
		-->
		<module name="MissingOverride" />

		<!--
			This check makes sure that all package annotations are in the
			package-info.java file.

			According to the Java JLS 3rd ed.

			The JLS does not enforce the placement of package
			annotations. This placement may vary based on implementation. The
			JLS does highly recommend that all package annotations are placed
			in the package-info.java file. See Java Language specification,
			sections 7.4.1.1.
		-->
		<module name="PackageAnnotation">
			<property name="javaFiveCompatibility" value="false" />
			<!-- <property name="javaFiveCompatibility" value="true" /> -->
		</module>

		<!--
			This check allows you to specify what warnings that
			SuppressWarnings is not allowed to suppress. You can
			also specify a list of TokenTypes that the configured
			warning(s) cannot be suppressed on.

			Limitations: This check does not consider conditionals
			inside the SuppressWarnings annotation.

			For example: @SupressWarnings((false) ? (true)
			? "unchecked" : "foo" : "unused") According to the above
			example, the "unused" warning is being suppressed not the
			"unchecked" or "foo" warnings. All of these warnings
			will be considered and matched against regardless of
			what the conditional evaluates to.
		-->
		<module name="SuppressWarnings">
			<!--
				The warnings property is a regex pattern. Any
				warning being suppressed matching this pattern
				will be flagged.
				default: "^$|^\s+$"

			<property name="regexp" value="^$|^\s+$" />
			-->
			<!--
				tokens to check

				default: CLASS_DEF, INTERFACE_DEF, ENUM_DEF,
				ANNOTATION_DEF, ANNOTATION_FIELD_DEF
				ENUM_CONSTANT_DEF PARAMETER_DEF VARIABLE_DEF
				METHOD_DEF CTOR_DEF

				options: CLASS_DEF, INTERFACE_DEF, ENUM_DEF,
				ANNOTATION_DEF, ANNOTATION_FIELD_DEF
				ENUM_CONSTANT_DEF PARAMETER_DEF VARIABLE_DEF
				METHOD_DEF CTOR_DEF
			<property name="tokens" value="CLASS_DEF, INTERFACE_DEF, ENUM_DEF, ANNOTATION_DEF, ANNOTATION_FIELD_DEF ENUM_CONSTANT_DEF PARAMETER_DEF VARIABLE_DEF METHOD_DEF CTOR_DEF" />
			-->
		</module>

		<!-- -->
		<!-- Block Checks -->
		<!-- -->

		<!--
			Finds nested blocks, i.e. blocks that are used freely in the code.

			Rationale: Nested blocks are often leftovers from the
			debugging process, they confuse the reader.
		-->
		<module name="AvoidNestedBlocks">
			<property name="allowInSwitchCase" value="true" />
			<!-- LZK: I believe this helps readability, so no warning -->
			<property name="severity" value="ignore" />
		</module>
		
		<!--
			Checks for empty blocks.
		-->
		<module name="EmptyBlock">
			<!-- policy on block contents. default is stmt -->
			<property name="option" value="text" />
			<!-- property name="option" value="stmt" / -->

			<!-- 
				blocks to check
				default all tokens: LITERAL_CATCH, LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_IF, LITERAL_FOR, LITERAL_TRY, LITERAL_WHILE, INSTANCE_INIT STATIC_INIT
			<property name="tokens" value="LITERAL_CATCH, LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_IF, LITERAL_FOR, LITERAL_TRY, LITERAL_WHILE, INSTANCE_INIT STATIC_INIT" />
			-->
		</module>

		<!--
			Checks for the placement of left curly braces ('{')
			for code blocks. The policy to verify is specified using
			property option. Policies eol and nlow take into account
			property maxLineLength.
		-->
		<module name="Lcurly">
			<!-- policy on placement of a left curly brace ('{'). default is eol -->
			<property name="option" value="nl" />
			<!--
			<property name="option" value="eol" />
			<property name="option" value="nlow" />
			-->

			<!-- maximum number of characters in a line. default is 80 -->
			<property name="maxLineLength" value="120" />

			<!-- Blocks to check: default all tokens:LASS_DEF, CTOR_DEF, INTERFACE_DEF, LITERAL_CATCH, LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF, LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, METHOD_DEF
			<property name="tokens" value="CLASS_DEF, CTOR_DEF, INTERFACE_DEF, LITERAL_CATCH, LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF, LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, METHOD_DEF" />
			-->
		</module>

		<!--
			Checks for braces around code blocks.
		-->
		<module name="NeedBraces">
			<!--
				blocks to check.
				default all tokens: LITERAL_DO, LITERAL_ELSE, LITERAL_IF, LITERAL_FOR, LITERAL_WHILE
			-->
		</module>

		<!--
			Checks the placement of right curly braces ('}') for else,
			try, and catch tokens. The policy to verify is specified
			using property option.
		-->
		<module name="Rcurly">
			<!-- policy on placement of a right curly brace ('}'). default is same -->
			<property name="option" value="alone" />
			<!--
			<property name="option" value="same" />
			-->


			<!-- Blocks to check: default subset tokens:LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE
			<property name="tokens" value="LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE" />
			-->

			<!-- should we check if '}' starts line. default is: true -->
			<property name="shouldStartLine" value="true" />
			<!-- <property name="shouldStartLine" value="false" /> -->
		</module>

		<!-- -->
		<!-- Section: Class Design -->
		<!-- -->

		<!--
			Checks that classes are designed for extension. More
			specifically, it enforces a programming style where
			superclasses provide empty "hooks" that can be implemented
			by subclasses.

			The exact rule is that nonprivate, nonstatic methods of
			classes that can be subclassed must either be

				* abstract or
				* final or
				* have an empty implementation

			Rationale: This API design style protects superclasses
			against beeing broken by subclasses. The downside is
			that subclasses are limited in their flexibility, in
			particular they cannot prevent execution of code in the
			superclass, but that also means that subclasses cannot
			corrupt the state of the superclass by forgetting to
			call the super method.
		-->
		<module name="DesignForExtension">
			<property name="severity" value="warning" />
		</module>

		<!--
			Checks that a class which has only private constructors
			is declared as final.
		-->
		<module name="FinalClass" />

		<!--
			Make sure that utility classes (classes that contain
			only static methods or fields in their API) do not have
			a public constructor.

			Rationale: Instantiating utility classes does not make
			sense. Hence the constructors should either be private or
			(if you want to allow subclassing) protected. A common
			mistake is forgetting to hide the default constructor.

			If you make the constructor protected you may want
			to consider the following constructor implementation
			technique to disallow instantiating subclasses:

			public class StringUtils // not final to allow subclassing
			{
				protected StringUtils() {
					// prevents calls from subclass
					throw new UnsupportedOperationException();
				}

				public static int count(char c, String s) {
					// ...
				}
			}
		-->
		<module name="HideUtilityClassConstructor" />


		<!--
			Check nested (internal) classes/interfaces are
			declared at the bottom of the class after all
			method and field declarations.
		-->
		<module name="InnerTypeLast" />
			<!-- LZK: Give developer freedom to improve readability -->
			<property name="severity" value="ignore" />
		</module>

		<!--
			Implements Bloch, Effective Java, Item 17 - Use Interfaces
			only to define types.

			According to Bloch, an interface should describe a
			type. It is therefore inappropriate to define an interface
			that does not contain any methods but only constants. The
			Standard class javax.swing.SwingConstants is an example
			of a class that would be flagged by this check.

			The check can be configured to also disallow marker
			interfaces like java.io.Serializable, that do not contain
			methods or constants at all.
		-->
		<module name="InterfaceIsType" />

		<!--
			Ensures that exceptions (defined as any class name
			conforming to some regular expression) are immutable. That
			is, have only final fields.

			The current algorithm is very simple it checks that
			all members of exception are final. User can still
			mutates an exception's instance (e.g. Throwable has
			setStackTrace(StackTraceElement[] stackTrace) method
			which changes stack trace). But, at least, all information
			provided by this exception type is unchangable.

			Rationale: Exception instances should represent an error
			condition. Having non final fields not only allows the
			state to be modified by accident and therefore mask
			the original condition but also allows developers to
			accidentally forget to initialise state thereby leading to
			code catching the exception to draw incorrect conclusions
			based on the state.
		-->
		<module name="MutableException">
			<!--
				pattern for name of exception class.
				default: "^.*Exception$|^.*Error$"
			<property name="format" value="^.*Exception$|^.*Error$" />
			-->
		</module>

		<!--
			Restricts throws statements to a specified count (default = 1).

			Rationale: Exceptions form part of a methods
			interface. Declaring a method to throw too many
			differently rooted exceptions makes exception handling
			onerous and leads to poor programming practices such as
			catch (Exception). This check forces developers to put
			exceptions into a heirachy such that in the simplest
			case, only one type of exception need be checked for
			by a caller but allows any sub-classes to be caught
			specifically if necessary.
		-->
		<module name="ThrowsCount">
			<!-- maximum allowed number of throws statments. default 1 -->
			<property name="max" value="3" />
			<property name="severity" value="warning" />
		</module>

		<!--
			Checks visibility of class members. Only static final
			members may be public; other class members must be private
			unless property protectedAllowed or packageAllowed is set.

			Public members are not flagged if the name matches
			the public member regular expression (contains
			"^serialVersionUID$" by default). Note: Checkstyle 2 used
			to include "^f[A-Z][a-zA-Z0-9]*$" in the default pattern
			to allow CMP for EJB 1.1 with the default settings. With
			EJB 2.0 it is not longer necessary to have public access
			for persistent fields, hence the default has been changed.

			Rationale: Enforce encapsulation.
		-->
		<module name="VisibilityModifier">
			<!-- whether package visible members are allowed. default: false -->
			<property name="packageAllowed" value="true" />
			<!-- whether protected members are allowed. default: false -->
			<property name="protectedAllowed" value="true" />
			<!--
				pattern for public members that should be ignored.
				default: "^serialVersionUID$"
			<property name="publicMemberPattern" value="^serialVersionUID$" />
			-->
		</module>

		<!-- -->
		<!-- Section: Coding -->
		<!-- -->

		<!--
			Checks that array initialization contains a trailing comma.

			int[] a = new int[]
			{
			1,
			2,
			3,
			};
					
			The check allows to not add a comma if both left
			and right curlys are on the same line.

			return new int[] { 0 };
						
			Rationale: Putting this comma in makes it easier
			to change the order of the elements or add new
			elements on the end.
		-->
		<module name="ArrayTrailingComma">
			<property name="severity" value="error" />
		</module>

		<!--
			Detects inline conditionals. An example inline conditional is this:

			String a = getParameter("a");
			String b = (a==null || a.length<1) ? null : a.substring(1);
			        
			Rationale: Some developers find inline
			conditionals hard to read, so their company's
			coding standards forbids them.
		-->
		<module name="AvoidInlineConditionals">
			<!-- this makes things easier to read -->
			<property name="severity" value="ignore" />
		</module>

		<!--
			Checks that classes that define a covariant
			equals() method also override method
			equals(java.lang.Object). Inspired by findbugs.

			Rationale: Mistakenly defining a covariant
			equals() method without overriding method
			equals(java.lang.Object) can produce unexpected
			runtime behaviour.
		-->
		<module name="CovariantEquals">
			<property name="severity" value="error" />
		</module>

		<!--
			The "double-checked locking" idiom (DCL) tries
			to avoid the runtime cost of synchronization. An
			example that uses the DCL idiom is this:

			public class MySingleton
			{
			    private static theInstance = null;

				private MySingleton() {}

				public MySingleton getInstance() {
					if ( theInstance == null ) { // synchronize only if necessary
						synchronized( MySingleton.class ) {
							if ( theInstance == null ) {
								theInstance = new MySingleton();
							}
						}
					}
				}
			}
																														        
			The problem with the DCL idiom in Java is that it
			just does not work correctly. Using it introduces
			bugs that are extremely hard to track down and
			reproduce. The "Double-Checked Locking is Broken"
			Declaration has an in depth explanation of the
			exact problem which has to do with the semantics
			of the Java memory model.

			The DoubleCheckedLocking check will find source
			code where a test is wrapped in a synchronized
			block that is wrapped in the same test, like in
			the example above.
		-->
		<module name="DoubleCheckedLocking">
			<property name="severity" value="error" />
		</module>

		<!--
			Detects empty statements (standalone ;).
		-->
		<module name="EmptyStatement">
			<property name="severity" value="error" />
		</module>

		<!--
			Checks that any combination of String literals
			with optional assignment is on the left side of
			an equals() comparison. The check also processes
			String.equalsIgnoreCase() invocations (which
			can be suppressed).

			Rationale: Calling the equals() method
			on String literals will avoid a potential
			NullPointerException. Also, it is pretty common
			to see null check right before equals comparisons
			which is not necessary in the below example.

			For example:

			String nullString = null;
			nullString.equals("My_Sweet_String");
			        
			should be refactored to:

			String nullString = null;
			"My_Sweet_String".equals(nullString);
					
			Limitations: If the equals method is overridden
			or a covariant equals method is defined and the
			implementation is incorrect (where s.equals(t)
			does not return the same result as t.equals(s))
			then rearranging the called on object and
			parameter may have unexpected results

			Java's Autoboxing feature has an affect on how
			this check is implemented. Pre Java 5 all IDENT
			+ IDENT object concatenations would not cause
			a NullPointerException even if null. Those
			situations could have been included in this
			check. They would simply act as if they surrounded
			by String.valueof() which would concatenate the
			String null.

			The following example will cause a
			NullPointerException as a result of what
			autoboxing does.

			Integer i = null, j = null;
			String number = "5"
			number.equals(i + j);
							        
			Since, it is difficult to determine what kind
			of Object is being concatenated all ident
			concatenation is considered unsafe.
		-->
		<module name="EqualsAvoidNull">
			<!-- whether to ignore String.equalsIgnoreCase() invocations -->
			<property name="ignoreEqualsIgnoreCase" value="false" />
			<property name="severity" value="error" />
		</module>

		<!--
			Checks that classes that override equals()
			also override hashCode().

			Rationale: The contract of equals() and
			hashCode() requires that equal objects have
			the same hashCode. Hence, whenever you override
			equals() you must override hashCode() to ensure
			that your class can be used in collections that
			are hash based.
		-->
		<module name="EqualsHashCode">
			<property name="severity" value="error" />
		</module>

		<!--
			Checks that local variables that never have their
			values changed are declared final. The check
			can be configured to also check that unchanged
			parameters are declared final.

			Notes:
			When configured to check parameters, the check
			ignores parameters of interface methods and
			abstract methods.
		-->
		<module name="FinalLocalVariable">
			<property name="severity" value="error" />
			<!-- tokens to check. default: VARIABLE_DEF -->
			<property name="tokens" value="PARAMETER_DEF, VARIABLE_DEF" />
		</module>

		<!--
			Checks that a local variable or a parameter
			does not shadow a field that is defined in the
			same class.
		-->
		<module name="HiddenField">
			<!-- Controls whether to ignore parameters of abstract methods.
				default: false 
			<property name="ignoreAbstractMethods" value="false" />
			-->

			<!-- Controls whether to ignore constructor parameters.
				default: false 
			<property name="ignoreConstructorParameter" value="false" />
			-->

			<!-- pattern for names to ignore. default: empty 
			<property name="ignoreFormat" value="" />
			-->

			<!-- Controls whether to ignore the parameter
				of a property setter method, where the property
				setter method for field "xyz" has name "setXyz",
				one parameter named "xyz", and return type void.

				default: empty 
			<property name="ignoreSetter" value="false" />
			-->

			<property name="severity" value="error" />

			<!-- tokens to check. default: PARAMETER_DEF, VARIABLE_DEF -->
			<property name="tokens" value="PARAMETER_DEF, VARIABLE_DEF" />
		</module>

		<!--
			Checks for illegal instantiations where a factory
			method is preferred.

			Rationale: Depending on the project, for
			some classes it might be preferable to create
			instances through factory methods rather than
			calling the constructor.

			A simple example is the java.lang.Boolean
			class. In order to save memory and CPU cycles,
			it is preferable to use the predefined constants
			TRUE and FALSE. Constructor invocations should
			be replaced by calls to Boolean.valueOf().

			Some extremely performance sensitive projects
			may require the use of factory methods for other
			classes as well, to enforce the usage of number
			caches or object pools.
		-->
		<module name="IllegalInstantiation">
			<property name="classes" value="java.lang.Boolean" />
			<property name="severity" value="error" />
		</module>

		<!--
			Checks for illegal tokens.

			Rational: Certain language features often lead
			to hard to maintain code or are non-obvious
			to novice developers. Other features may be
			discouraged in certain frameworks, such as not
			having native methods in EJB components.
		-->
		<module name="IllegalToken">
			<property name="severity" value="warning" />
			<!-- tokens to check. default: LITERAL_SWITCH, POST_INC, POST_DEC
			<property name="tokens" value="LITERAL_NATIVE, LITERAL_SWITCH, POST_INC, POST_DEC" />
			-->
			<property name="tokens" value="LITERAL_NATIVE" />
		</module>

		<!--
			Checks for illegal token text.
		-->
		<module name="IllegalTokenText">
			<!-- regexp of social security number? -->
			<property name="format" value="[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]" />
			<property name="ignoreCase" value="false" />
			<property name="message" value="No Social Security numbers in code!!" />
			<property name="severity" value="error" />
			<property name="tokens" value="STRING_LITERAL" />
		</module>

		<!--
			Checks for assignments in subexpressions, such
			as in String s = Integer.toString(i = 2);.

			Rationale: With the exception of for iterators,
			all assignments should occur in their own toplevel
			statement to increase readability. With inner
			assignments like the above it is difficult to
			see all places where a variable is set.
		-->
		<module name="InnerAssignment">
			<property name="severity" value="error" />
			<!-- assignments to check
				default=ASSIGN, BAND_ASSIGN, BOR_ASSIGN, BSR_ASSIGN, BXOR_ASSIGN, DIV_ASSIGN, MINUS_ASSIGN, MOD_ASSIGN, PLUS_ASSIGN, SL_ASSIGN, SR_ASSIGN, STAR_ASSIGN
			<property name="tokens" value="error" />
			-->
		</module>

		<!--
			Checks that there are no "magic numbers", where
			a magic number is a numeric literal that is not
			defined as a constant. By default, -1, 0, 1,
			and 2 are not considered to be magic numbers.
		-->
		<module name="MagicNumber">
			<!-- ignore magic numbers in annotation declarations. default: false -->
			<property name="ignoreAnnotation" value="false" />
			<!-- ignore magic numbers in hashCode methods default: false -->
			<property name="ignoreHashCodeMethod" value="false" />
			<!-- non-magic numbers. default: -1, 0, 1, 2 -->
			<property name="ignoreNumbers" value="-1, 0, 1" />
			<property name="severity" value="error" />
			<!-- tokens to check.
				default: NUM_DOUBLE, NUM_FLOAT, NUM_INT, NUM_LONG
			-->
			<property name="tokens" value="NUM_DOUBLE, NUM_FLOAT, NUM_INT, NUM_LONG" />
		</module>

		<!--
			Checks that switch statement has "default" clause.

			Rationale: It's usually a good idea to introduce
			a default case in every switch statement. Even
			if the developer is sure that all currently
			possible cases are covered, this should be
			expressed in the default branch, e.g. by using
			an assertion. This way the code is protected
			aginst later changes, e.g. introduction of new
			types in an enumeration type.
		-->
		<module name="MissingSwitchDefault">
			<property name="severity" value="error" />
		</module>

		<!--
			Check for ensuring that for loop control
			variables are not modified inside the for
			block. An example is:

			for (int i = 0; i < 1; i++) {
			    i++;
			}
				        
			Rationale: If the control variable is modified
			inside the loop body, the program flow becomes
			more difficult to follow. An option is to replace
			the for loop with a while loop.
		-->
		<module name="ModifiedControlVariable">
			<property name="severity" value="error" />
		</module>

		<!--
			Checks for redundant exceptions declared in throws
			clause such as duplicates, unchecked exceptions
			or subclasses of another declared exception.
		-->
		<module name="RedundantThrows">
			<!-- whether unchecked exceptions in throws are allowed or not
				default: false
				LZK: be explicit to the caller
			-->
			<property name="allowUnchecked" value="true" />
			<!-- whether subclass of another declared
				exception is allowed in throws clause.
				default: false
				LZK: be explicit to the caller
			-->
			<property name="allowSubclasses" value="true" />
			<!-- This check may need to load exception
				classes mentioned in the @throws tag to check
				whether they are RuntimeExceptions. If loading
				the class fails, this property allows to control
				checkstyle's error handling. If set to false
				a classpath configuration problem is assumed
				and the TreeWalker stops operating on the
				class completely. If set to true (the default),
				checkstyle assumes a typo or refactoring problem
				in the javadoc and logs the problem in the
				normal checkstyle report (potentially masking
				a configuration error).
				default: true
			-->
			<property name="logLoadErrors" value="true" />
			<property name="severity" value="error" />
			<!-- When logLoadErrors is set to true, the
				TreeWalker completely processes a class and
				displays any problems with loading exceptions
				as checkstyle violations. When this property
				is set to true, the violations generated when
				logLoadErrors is set true are suppressed from
				being reported as violations in the checkstyle
				report.
				default: false
			-->
			<property name="suppressLoadErrors" value="false" />
		</module>

		<!--
			Checks for overly complicated boolean
			expressions. Currently finds code like if (b ==
			true), b || true, !false, etc.

			Rationale: Complex boolean logic makes code hard
			to understand and maintain.
		-->
		<module name="SimplifyBooleanExpression">
			<property name="severity" value="error" />
		</module>

		<!--
			Checks for overly complicated boolean return
			statements. For example the following code

			if (valid())
			    return false;
			else
				return true;
					
			could be written as:

			return !valid();
					
			The Idea for this Check has been shamelessly
			stolen from the equivalent PMD rule.
		-->
		<module name="SimplifyBooleanReturn">
			<property name="severity" value="error" />
		</module>

		<!--
			Checks that string literals are not used with == or !=.

			Rationale: Novice Java programmers often use code like:

			if (x == "something")
			        
			when they mean

			if ("something".equals(x))
		-->
		<module name="StringLiteralEquality">
			<property name="severity" value="error" />
		</module>

		<!--
			Restricts nested for blocks to a specified depth (default = 1).
		-->
		<module name="NestedForDepth">
			<!-- allowed nesting depth. default: 1 -->
			<property name="max" value="2" />
			<property name="severity" value="warning" />
		</module>

		<!--
			Restricts nested if-else blocks to a specified depth (default = 1).
		-->
		<module name="NestedIfDepth">
			<!-- allowed nesting depth. default: 1 -->
			<property name="max" value="3" />
			<property name="severity" value="error" />
		</module>

		<!--
			Restricts nested try blocks to a specified depth (default = 1).
		-->
		<module name="NestedTryDepth">
			<!-- allowed nesting depth. default: 1 -->
			<property name="max" value="2" />
			<property name="severity" value="warning" />
		</module>

		<!--
			Checks that the clone method is not overridden
			from the Object class.

			Rationale: The clone method relies on
			strange/hard to follow rules that do not work in
			all situations. Consequently, it is difficult
			to override correctly. Below are some of the
			rules/reasons why the clone method should
			be avoided.

			*  Classes supporting the clone method should
			implement the Cloneable interface but the
			Cloneable interface does not include the clone
			method. As a result, it doesn't enforce the
			method override.
			*  The Cloneable interface forces the Object's clone
			method to work correctly. Without implementing
			it, the Object's clone method will throw a
			CloneNotSupportedException.
			*  Non-final classes must return the object returned
			from a call to super.clone().
			*  Final classes can use a constructor to create
			a clone which is different from non-final classes.
			*  If a super class implements the clone method
			incorrectly all subclasses calling super.clone()
			are doomed to failure.
			*  If a class has references to mutable objects
			then those object references must be replaced
			with copies in the clone method after calling
			super.clone().
			*  The clone method does not work correctly with
			final mutable object references because final
			references cannot be reassigned.
			*  If a super class overrides the clone method
			then all subclasses must provide a correct
			clone implementation.

			Two alternatives to the clone method,
			in some cases, is a copy constructor or a
			static factory method to return copies of an
			object. Both of these approaches are simpler
			and do not conflict with final fields. The
			do not force the calling client to handle a
			CloneNotSuportException. They also are typed
			therefore no casting is necessary. Finally, they
			are more flexible since they can take interface
			types rather than concrete classes.

			Sometimes a copy constructor or static factory
			is not an acceptable alternative to the clone
			method. The example below highlights the
			limitation of a copy constructor (or static
			factory). Assume Square is a subclass for Shape.

			Shape s1 = new Square();
			System.out.println(s1 instanceof Square); //true

			...assume at this point the code knows nothing
			of s1 being a Square that's the beauty of
			polymorphism but the code wants to copy the Square
			which is declared as a Shape, its super type...

			Shape s2 = new Shape(s1); //using the copy constructor
			System.out.println(s2 instanceof Square); //false

			The working solution (without knowing about all
			subclasses and doing many casts) is to do the
			following (assuming correct clone implementation).

			Shape s2 = s1.clone();
			System.out.println(s2 instanceof Square); //true

			Just keep in mind if this type of polymorphic
			cloning is required then a properly implemented
			clone method may be the best choice.

			Much of this information was taken from Effective
			Java: Programming Language Guide First Edition
			by Joshua Bloch pages 45-52. Give Bloch credit
			for writing an excellent book.

			This check is almost exactly the same as the
			{@link NoFinalizerCheck}
		-->
		<module name="NoClone">
			<property name="severity" value="warning" />
		</module>

		<!--
			Verifies there are no finalize() methods defined in a class.
		-->
		<module name="NoFinalizer">
			<property name="severity" value="warning" />
		</module>

		<!--
			Checks that an overriding clone() method invokes super.clone().

			Reference: Object.clone().
			http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Object.html#clone()
		-->
		<module name="SuperClone">
			<property name="severity" value="error" />
		</module>

		<!--
			Checks that an overriding finalize() method invokes super.finalize().

			Reference: Cleaning Up Unused Objects.
			http://java.sun.com/docs/books/tutorial/java/data/garbagecollection.html
		-->
		<module name="SuperFinalize">
			<property name="severity" value="error" />
		</module>

		<!--
			Catching java.lang.Exception, java.lang.Error
			or java.lang.RuntimeException is almost never
			acceptable.

			Rationale: Junior developers often simply
			catch Exception in an attempt to handle
			multiple exception classes. This unfortunately
			leads to code that inadvertantly catchs NPE,
			OutOfMemoryErrors, etc.
		-->
		<module name="IllegalCatch">
			<!-- exception class names to reject.
				default: "java.lang.Exception, java.lang.Throwable, java.lang.RuntimeException"
			<property name="illegalClassNames" value="java.lang.Exception, java.lang.Throwable, java.lang.RuntimeException" />
			-->
			<property name="severity" value="error" />
		</module>

		<!--
			This check can be used to ensure that types are
			not declared to be thrown. Declaring to throw
			java.lang.Error or java.lang.RuntimeException
			is almost never acceptable.
		-->
		<module name="IllegalThrows">
			<!-- names of methods to ignore. default: finalize
			<property name="ignoredMethodNames" value="finalize" />
			-->
			<!-- throw class names to reject.
				default: java.lang.Throwable, java.lang.Error,
						java.lang.RuntimeExcpetion
			-->
			<property name="illegalClassNames" value="java.lang.Throwable, java.lang.Error, java.lang.RuntimeExcpetion, java.io.IOException" />
			<property name="severity" value="error" />
		</module>

		<!--
			Ensure a class has a package declaration, and
			(optionally) whether the package name matches
			the directory name for the source file.

			Rationale: Classes that live in the null package
			cannot be imported. Many novice developers are
			not aware of this.
		-->
		<module name="PackageDeclaration">
			<!-- whether to ignore checking that the
				package declaration matches the source directory
				name. default: false
			-->
			<property name="ignoreDirectoryName" value="false" />
			<property name="severity" value="error" />
		</module>

		<!--
			Ensures that the setUp(), tearDown()methods are
			named correctly, have no arguments, return void
			and are either public or protected.

			Also ensures that suite() is named correctly,
			have no arguments, return junit.framewotk.Test,
			public and static.

			Rationale: often times developers will misname
			one or more of these methods and not realise
			that the method is not being called.
		-->
		<module name="JUnitTestCase">
			<property name="severity" value="error" />
		</module>

		<!--
			Restricts the number of return statements. Default
			= 2. Ignores specified methods (equals()
			by default).

			Rationale: Too many return points can be
			indication that code is attempting to do too
			much or may be difficult to understand.
		-->
		<module name="ReturnCount">
			<!-- method names to ingore. default "^equals$" -->
			<property name="format" value="^equals$" />
			<!-- maximum allowed number of return statements. default: 2 -->
			<property name="max" value="3" />
			<property name="severity" value="error" />
		</module>

		<!--
			Checks that particular class are never used as
			types in variable declarations, return values
			or parameters. Includes a pattern check that by
			default disallows abstract classes.

			Rationale: Helps reduce coupling on concrete
			classes. In addition abstract classes should
			be thought of a convenience base class
			implementations of interfaces and as such are
			not types themselves.
		-->
		<module name="IllegalType">
			<!-- pattern for illegal class name.
				default: ^(.*[\\.])?Abstract.*$
			<property name="format" value="^(.*[\\.])?Abstract.*$" />
			-->
			<!-- methods that should not be checked.
				default: getInitialContext, getEnvironment
			<property name="ignoredMethodNames" value="getInitialContext, getEnvironment" />
			-->
			<!-- classes that should not be used as types
				in variable declarations, return values or
				parameters.
				default: "java.util.GregorianCalendar,
				java.util.Hashtable, java.util.HashSet,
				java.util.HashMap, java.util.ArrayList,
				java.util.LinkedList,
				java.util.LinkedHashMap,
				java.util.LinkedHashSet,
				java.util.TreeSet, java.util.TreeMap,
				java.util.Vector"
				LZK: adding Thread since we should be using concurrent library now
			-->
			<property name="illegalClassNames" value="java.lang.Thread, java.util.GregorianCalendar, java.util.Hashtable, java.util.HashSet, java.util.HashMap, java.util.ArrayList, java.util.LinkedList, java.util.LinkedHashMap, java.util.LinkedHashSet, java.util.TreeSet, java.util.TreeMap, java.util.Vector" />
			<!-- abstract classes that may be used as types.
				default: ""
			<property name="legalAbstractClassNames" value="" />
			-->
			<property name="severity" value="error" />
			<!-- tokens to check default: "PARAMETER_DEF, VARIABLE_DEF, METHOD_DEF" -->
			<property name="tokens" value="PARAMETER_DEF, VARIABLE_DEF, METHOD_DEF" />
		</module>

		<!--
			According to Code Conventions for the Java
			Programming Language , the parts of a class
			or interface declaration should appear in the
			following order:

			1. Class (static) variables. First the public
			class variables, then the protected, then package
			level (no access modifier), and then the private.
			2. Instance variables. First the public class
			variables, then the protected, then package level
			(no access modifier), and then the private.
			3. Constructors
			4. Methods
		-->
		<module name="DeclarationOrder">
			<!-- default: false -->
			<property name="ignoreConstructors" value="false" />
			<!-- default: false -->
			<property name="ignoreMethods" value="false" />
			<!-- default: false -->
			<property name="ignoreModifiers" value="false" />
			<property name="severity" value="warning" />
		</module>

		<!--
			Check that the default is after all the cases
			in a switch statement.

			Rationale: Java allows default anywhere within
			the switch statement. But it is more readable
			if it comes after the last case.
		-->
		<module name="DefaultComesLast">
			<property name="severity" value="error" />
		</module>

		<!--
			Checks if any class or object member explicitly
			initialized to default for its type value (null
			for object references, zero for numeric types
			and char and false for boolean.

			Rationale: each instance variable gets initialized
			twice, to the same value. Java initializes each
			instance variable to its default value (0 or null)
			before performing any initialization specified
			in the code. So in this case, x gets initialized
			to 0 twice, and bar gets initialized to null
			twice. So there is a minor inefficiency. This
			style of coding is a hold-over from C/C++ style
			coding, and it shows that the developer isn't
			really confident that Java really initializes
			instance variables to default values.
		-->
		<module name="ExplicitInitialization">
			<property name="severity" value="warning" />
		</module>

		<!--
			Checks for fall through in switch statements
			Finds locations where a case contains Java code
			- but lacks a break, return, throw or continue
			statement.

			The check honores special comments to supress
			the warning. By default the text "fallthru",
			"fall through", "fallthrough", "falls through"
			and "fallsthrough" are recognized (case
			sensitive). The comment containing this words
			must be a one-liner and must be on the last
			none-empty line before the case triggering the
			warning or on the same line before the case
			(urgly, but possible).

			switch (i){
				case 0:
					i++; // fall through

				case 1:
					i++;
					// falls through
				case 2: {
					i++;
				}
				// fallthrough
				case 3:
					i++;
				/* fallthru */
				case 4:
					i++
					break;
			}
										
			Note: the check works in assumption that there
			is no unreachable code in the case.
		-->
		<module name="FallThrough">
			<!-- Whether we need to check last case group or not. -->
			<property name="checkLastCaseGroup" value="false" />
			<!-- Regulare expression to match the relief
				comment that supresses the warning about a
				fall through.
				default: "fallthru|falls? ?through"
			<property name="reliefPattern" value="fallthru|falls? ?through" />
			-->
			<property name="severity" value="error" />
		</module>

		<!--
			Checks that each variable declaration is in its
			own statement and on its own line.

			Rationale: the SUN Code conventions chapter
			6.1 recommends that declarations should be one
			per line/statement.
			http://java.sun.com/docs/codeconv/html/CodeConventions.doc5.html#2991
		-->
		<module name="MultipleVariableDeclarations">
			<property name="severity" value="error" />
		</module>

		<!--
			Disallow assignment of parameters.

			Rationale: Parameter assignment is often
			considered poor programming practice. Forcing
			developers to declare parameters as final is often
			onerous. Having a check ensure that parameters are
			never assigned would give the best of both worlds.
		-->
		<module name="ParameterAssignment">
			<property name="severity" value="error" />
		</module>

		<!--
			Checks that classes (except abtract one) define
			a ctor and don't rely on the default one.
		-->
		<module name="MissingCtor">
			<property name="severity" value="warning" />
		</module>

		<!--
			Checks that code doesn't rely on the
			"this." default, i.e. references to instance
			variables and methods of the present object
			are explicitly of the form "this.varName" or
			"this.methodName(args)".
		-->
		<module name="RequireThis">
			<property name="checkFields" value="true" />
			<property name="checkMethods" value="true" />
			<property name="severity" value="error" />
		</module>

		<!--
			Checks for the use of unnecessary parentheses.
			LZK: I think this increases readability
		-->
		<module name="EmptyStatement">
			<property name="severity" value="ignore" />
		</module>

		<!--
			Checks there is only one statement per line. The
			following line will be flagged as an error:

			x = 1; y = 2; // Two statments on a single line.
		-->
		<module name="OneStatementPerLine">
			<property name="severity" value="error" />
		</module>

		<!-- -->
		<!-- Section: Imports -->
		<!-- -->
		</module>
		<!-- -->
		<!-- Section: Javadoc Comments -->
		<!-- -->
		</module>
		<!-- -->
		<!-- Section: Metrics -->
		<!-- -->
		</module>
		<!-- -->
		<!-- Section: Miscellaneous -->
		<!-- -->
		</module>
		<!-- -->
		<!-- Section: Modifiers -->
		<!-- -->
		</module>
		<!-- -->
		<!-- Section: Naming Conventions -->
		<!-- -->
		</module>
		<!-- -->
		<!-- Section: Regexp -->
		<!-- -->
		</module>
		<!-- -->
		<!-- Section: Size Violations -->
		<!-- -->
		</module>
		<!-- -->
		<!-- Section: Whitespace -->
		<!-- -->
		</module>
	</module> <!-- name="TreeWalker" -->

	<!-- -->
	<!-- Section: Duplicate Code -->
	<!-- -->
	<module name="StrictDuplicateCode">
		<!-- file type extension of files to process.
			default: {}
		<property name="fileExtensions" value="{}" />
		-->
		<!-- how many lines must be equal to be considered a duplicate.
			default: 12
		-->
		<property name="min" value="10" />
		<property name="severity" value="error" />
	</module>

	<!-- -->
	<!-- Section: Headers -->
	<!-- -->

	<!--
		Checks that a source file begins with a specified
		header. Property headerFile specifies a file that
		contains the required header. Alternatively,
		the header specification can be set directly
		in the header property without the need for an
		external file.

		Property ignoreLines specifies the line numbers to
		ignore when matching lines in a header file. This
		property is very useful for supporting headers
		that contain copyright dates. For example,
		consider the following header:

		line 1: ////////////////////////////////////////////////////////////////////
		line 2: // checkstyle:
		line 3: // Checks Java source code for adherence to a set of rules.
		line 4: // Copyright (C) 2002  Oliver Burn
		line 5: ////////////////////////////////////////////////////////////////////
				
		Since the year information will change over
		time, you can tell Checkstyle to ignore line 4
		by setting property ignoreLines to 4.
	-->
	<module name="Header">
		<!-- character encoding to use when reading the headerFile
			default: the charset property of the parent Checker module
		<property name="charset" value="UTF-8" />
		-->
		<!-- the required header specified
			inline. Individual header lines must be separated
			by the string "\n" (even on platforms with a
			different line separator), see examples below.
		<property name="header" value="" />
		-->
		<!-- name of the file containing the required header.
		<property name="headerFile" value="" />
		-->
		<!-- file type extension of files to process
		<property name="fileExtensions" value="" />
		-->
		<!-- line numbers to ignore
		<property name="ignoreLines" value="" />
		-->
		<property name="severity" value="ignore" />
	</module>

	<!--
		Checks the header of a source file against a
		header that contains a regular expression for
		each line of the source header.

		Rationale: In some projects checking against a
		fixed header is not sufficient, e.g. the header
		might require a copyright line where the year
		information is not static.

		For example, consider the following header:

		line  1: ^/{71}$
		line  2: ^// checkstyle:$
		line  3: ^// Checks Java source code for adherence to a set of rules\.$
		line  4: ^// Copyright \(C\) \d\d\d\d  Oliver Burn$
		line  5: ^// Last modification by \$Author.*\$$
		line  6: ^/{71}$
		line  7:
		line  8: ^package
		line  9:
		line 10: ^import
		line 11:
		line 12: ^/\*\*
		line 13: ^ \*([^/]|$)
		line 14: ^ \*/
				
		Lines 1 and 6 demonstrate a more compact notation
		for 71 '/' characters. Line 4 enforces that the
		copyright notice includes a four digit year. Line
		5 is an example how to enforce revision control
		keywords in a file header. Lines 12-14 is a
		template for javadoc (line 13 is so complicated
		to remove conflict with and of javadoc comment).

		Different programming languages have different
		comment syntax rules, but all of them start a
		comment with a non-word character. Hence you
		can often use the non-word character class to
		abstract away the concrete comment syntax and
		allow checking the header for different languages
		with a single header definition. For example,
		consider the following header specification (note
		that this is not the full Apache license header):

		line 1: ^#!
		line 2: ^<\?xml.*>$
		line 3: ^\W*$
		line 4: ^\W*Copyright 2006 The Apache Software Foundation or its licensors, as applicable\.$
		line 5: ^\W*Licensed under the Apache License, Version 2\.0 \(the "License"\);$
		line 6: ^\W*$
				
		Lines 1 and 2 leave room for technical header
		lines, e.g. the "#!/bin/sh" line in Unix shell
		scripts, or the xml file header of XML files. Set
		the multiline property to "1, 2" so these lines
		can be ignored for file types where they do no
		apply. Lines 3 through 6 define the actual header
		content. Note how lines 2, 4 and 5 use escapes
		for characters that have special regexp semantics.
	-->
	<module name="RegexpHeader">
		<!-- character encoding to use when reading the headerFile
			default: the charset property of the parent Checker module
		<property name="charset" value="UTF-8" />
		-->
		<!-- the required header specified
			inline. Individual header lines must be separated
			by the string "\n" (even on platforms with a
			different line separator),  and regular
			expressions must not span multiple lines.
			see examples below.
		<property name="header" value="" />
		-->
		<!-- file type extension of files to process
		<property name="fileExtensions" value="" />
		-->
		<!-- name of the file containing the required header.
		<property name="headerFile" value="" />
		-->
		<!-- line numbers to repeat (zero or more times)
		<property name="multiLines" value="" />
		-->
		<property name="severity" value="ignore" />
	</module>
	
	<!-- vim: set noexpandtab tabstop=4 shiftwidth=4: -->
</module>
